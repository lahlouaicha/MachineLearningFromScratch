# -*- coding: utf-8 -*-
"""LDA_Classifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BuXqF6eYsdM8UlZ_PooDdSiTnyFq1s2U
"""

import numpy as np
from collections import Counter

class LDA_Classifier():

  """ 
  This class corresponds to the implementation of the Linear Discriminant Analysis Classifier.
  """

  def __init__(self):
    """
    Initialization of attributes of the class.
    """
    self.threshold_left = None
    self.threshold_right = None
    self.sigma_inverse = None
    self.mu_negative = None
    self.mu_positive = None
  
  def get_labels(self, y): 
    neg_label = list(Counter(y).keys())[0]
    pos_label = list(Counter(y).keys())[1]
    return neg_label, pos_label

  def fit(self, X, y):

    """
    Method to train the model on X, and y 
    
    - X : design matrix
    - y : labels 
    """

    self.neg_label, self.pos_label = self.get_labels(y)

    # Size of training set
    n = X.shape[0]

    # Number of positive observations
    m = len(y[y==self.pos_label])

    # Proportion of positive and negative class 
    pi_positive = m/n
    pi_negative = 1 - pi_positive

    # Positive and negative samples
    X_positive = X[y == self.pos_label,:]
    X_negative = X[y == self.neg_label,:]

    # Mean of positive and negative class
    mu_positive =  X_positive.mean(axis=0)
    mu_negative = X_negative.mean(axis = 0)

    # Sigma of positive and negative class
    sigma_positive = (X_positive - mu_positive).transpose()  @ (X_positive - mu_positive) / (m - 1)
    sigma_negative= (X_negative- mu_negative).transpose()  @ (X_negative - mu_negative) / (n - m - 1) 
    sigma = ((m-1) * sigma_positive + (n-m - 1) * sigma_negative) / (n - 2)
    sigma_inverse = np.linalg.inv(sigma)

    # Thresholds for classifications 
    threshold_right= 0.5 * (np.transpose(mu_positive) @ sigma_inverse @ mu_positive 
                          - np.transpose(mu_negative) @ sigma_inverse @ mu_negative)+np.log(1 - m / n) - np.log(m / n)
    threshold_left = sigma_inverse @ (mu_positive - mu_negative)

    # Keep in attributes useful terms
    self.threshold_right = threshold_right
    self.threshold_left =threshold_left
    self.sigma_inverse= sigma_inverse
    self.mu_positive = mu_positive
    self.mu_negative = mu_negative

    return self

  def predict(self, X):
    """
    Function to predict the labels of the features in the matrix X. 

    - X: feature matrix used for prediction
    """
    # List of predictions 
    predictions = []

    for row in range(len(X)):
      x = X[row,:] 
      # If X matches the positive label treshold 
      if np.transpose(x) @ self.threshold_left > self.threshold_right:
        predictions.append(self.pos_label)
      # Otherwise
      else:
        predictions.append(self.neg_label)

    return predictions